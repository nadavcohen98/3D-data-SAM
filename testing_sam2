import logging
import os
import sys
import inspect
import traceback

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("SAM2Explorer")

def explore_sam2_api():
    """Explore SAM2's API in detail to understand how to use it"""
    logger.info("Starting SAM2 API exploration")
    
    try:
        # Import SAM2
        from sam2.sam2_image_predictor import SAM2ImagePredictor
        from sam2.build_sam import build_sam2_hf
        import torch
        
        # Initialize SAM2 - we know this works from previous tests
        logger.info("Initializing SAM2 with facebook/sam2-hiera-large")
        sam2_model = build_sam2_hf("facebook/sam2-hiera-large")
        predictor = SAM2ImagePredictor(sam2_model)
        logger.info("SAM2 initialized successfully")
        
        # Examine available methods
        logger.info("Available methods on SAM2ImagePredictor instance:")
        for method_name in dir(predictor):
            if not method_name.startswith('_'):
                logger.info(f"  - {method_name}")
                
                # For each method, get its signature
                try:
                    method = getattr(predictor, method_name)
                    if callable(method):
                        signature = inspect.signature(method)
                        logger.info(f"    Signature: {signature}")
                        
                        # Get docstring if available
                        if method.__doc__:
                            doc = method.__doc__.strip().split('\n')[0]  # First line only
                            logger.info(f"    Doc: {doc}")
                except Exception as e:
                    logger.warning(f"    Error examining method: {e}")
        
        # Look deeper at predict method specifically
        if hasattr(predictor, 'predict'):
            logger.info("\nDetailed analysis of the 'predict' method:")
            predict_method = getattr(predictor, 'predict')
            logger.info(f"Full signature: {inspect.signature(predict_method)}")
            logger.info(f"Full docstring:\n{predict_method.__doc__}")
            
            # Examine any example usage in the docstring
            if predict_method.__doc__ and "Example" in predict_method.__doc__:
                example_section = predict_method.__doc__.split("Example")[1]
                logger.info(f"Example usage from docstring:\n{example_section}")
        
        # Test if we can make a simple prediction with a random image
        logger.info("\nTesting prediction with a random image:")
        try:
            # Create a simple random image (1x3x256x256)
            random_image = torch.rand(1, 3, 256, 256).to(device="cuda" if torch.cuda.is_available() else "cpu")
            
            # Create a simple embedding (if needed)
            random_embedding = torch.rand(1, 256, 64, 64).to(device="cuda" if torch.cuda.is_available() else "cpu")
            
            # Set the image
            logger.info("Setting image on predictor")
            predictor.set_image(random_image)
            
            # Try different prediction approaches
            logger.info("Trying different prediction approaches:")
            
            # Approach 1: Using predict method directly
            logger.info("Approach 1: Using predict() method")
            try:
                # Try with point prompts
                points = torch.tensor([[[128, 128]]], dtype=torch.float32)
                point_labels = torch.tensor([[1]])
                result = predictor.predict(
                    point_coords=points,
                    point_labels=point_labels
                )
                logger.info(f"Success! predict() returned result of type: {type(result)}")
                logger.info(f"Result structure: {result.keys() if isinstance(result, dict) else 'not a dict'}")
            except Exception as e:
                logger.warning(f"predict() method failed: {e}")
            
            # Approach 2: Try predict_batch
            logger.info("Approach 2: Using predict_batch() method")
            try:
                result = predictor.predict_batch(
                    point_coords=points,
                    point_labels=point_labels
                )
                logger.info(f"Success! predict_batch() returned result of type: {type(result)}")
            except Exception as e:
                logger.warning(f"predict_batch() method failed: {e}")
            
            # Approach 3: Try passing embeddings
            logger.info("Approach 3: Using predict() with embeddings")
            try:
                result = predictor.predict(
                    point_coords=None,
                    point_labels=None,
                    embeddings=random_embedding
                )
                logger.info(f"Success! predict() with embeddings returned result of type: {type(result)}")
            except Exception as e:
                logger.warning(f"predict() with embeddings failed: {e}")
                
            # Extract and analyze the results
            if 'result' in locals() and result is not None:
                logger.info("Analyzing prediction result:")
                
                # Check if it's a dictionary
                if isinstance(result, dict):
                    for key, value in result.items():
                        if isinstance(value, torch.Tensor):
                            logger.info(f"  - {key}: Tensor of shape {value.shape}, dtype {value.dtype}")
                        else:
                            logger.info(f"  - {key}: {type(value)}")
                
                # If it's a tensor or has specific attributes
                elif hasattr(result, 'shape'):
                    logger.info(f"Result is a tensor of shape {result.shape}")
                
                else:
                    logger.info(f"Result is of type {type(result)}")
        
        except Exception as e:
            logger.error(f"Error during prediction test: {e}")
            logger.error(traceback.format_exc())
    
    except Exception as e:
        logger.error(f"Error during SAM2 API exploration: {e}")
        logger.error(traceback.format_exc())
    
    logger.info("SAM2 API exploration complete")

if __name__ == "__main__":
    explore_sam2_api()
